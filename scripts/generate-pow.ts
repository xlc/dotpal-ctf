#!/usr/bin/env bun
// PoW Generator for CTF pallet - generated by polka.codes
// This utility script generates a valid proof-of-work for the CTF pallet

import { u8aToHex, hexToU8a, stringToU8a, u8aConcat } from '@polkadot/util';
import { blake2AsU8a, cryptoWaitReady, decodeAddress } from '@polkadot/util-crypto';
import { BN } from 'bn.js';

// Default parameters
const DEFAULT_ACCOUNT = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY'; // Alice's address
const DEFAULT_DIFFICULTY = 10;
const DEFAULT_NONCE = 0;
const DEFAULT_MAX_ATTEMPTS = 1000000;

// Convert a hash byte array to U256 for comparison
function hashToU256(hash: Uint8Array): BN {
  const reversedHash = hash.slice().reverse();
  return new BN(reversedHash);
}

// Find a valid proof of work
async function findValidProofOfWork(
  accountId: string, 
  nonce: number, 
  difficulty: number,
  maxAttempts = DEFAULT_MAX_ATTEMPTS,
  silent = false
): Promise<string | null> {
  // Convert account ID to bytes
  const accountBytes = decodeAddress(accountId);
  const nonceBytes = new Uint8Array(new BN(nonce).toArray('le', 4));
  const difficultyBytes = new Uint8Array(new BN(difficulty).toArray('le', 4));
  
  // Calculate target value: 2^(256-difficulty)
  const target = new BN(2).pow(new BN(256 - difficulty));
  
  if (!silent) {
    console.log(`Target value: ${target.toString(16)}`);
    console.log(`Finding proof-of-work for account ${accountId}, nonce ${nonce}, difficulty ${difficulty}`);
    console.log(`This may take some time depending on difficulty...`);
  }
  
  // Progress tracking
  let lastProgressUpdate = Date.now();
  
  // Try different values until we find a valid proof or reach max attempts
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    // Generate a random work value
    const workBytes = crypto.getRandomValues(new Uint8Array(32));
    
    // Concatenate all inputs
    const input = u8aConcat(accountBytes, nonceBytes, difficultyBytes, workBytes);
    
    // Calculate the hash using blake2
    const hash = blake2AsU8a(input, 256);
    
    // Convert hash to BN for comparison
    const hashValue = hashToU256(hash);
    
    // Check if the hash is less than the target
    if (hashValue.lt(target)) {
      // We found a valid proof!
      if (!silent) {
        console.log(`\nFound valid proof after ${attempt+1} attempts!`);
      }
      return u8aToHex(workBytes);
    }
    
    // Show progress every 10000 attempts
    if (!silent && attempt % 10000 === 0 && attempt > 0) {
      const now = Date.now();
      const elapsedSec = (now - lastProgressUpdate) / 1000;
      if (elapsedSec >= 2) {
        const hashesPerSec = Math.floor(10000 / elapsedSec);
        process.stdout.write(`\rTried ${attempt} attempts... (${hashesPerSec} H/s)`);
        lastProgressUpdate = now;
      }
    }
  }
  
  if (!silent) {
    console.log(`\nReached maximum attempts (${maxAttempts}) without finding a valid proof`);
  }
  return null;
}

// Verify if a proof of work is valid
function verifyProofOfWork(
  accountId: string,
  nonce: number,
  difficulty: number,
  work: string
): boolean {
  // Convert inputs to bytes
  const accountBytes = decodeAddress(accountId);
  const nonceBytes = new Uint8Array(new BN(nonce).toArray('le', 4));
  const difficultyBytes = new Uint8Array(new BN(difficulty).toArray('le', 4));
  const workBytes = hexToU8a(work);
  
  // Concatenate all inputs
  const input = u8aConcat(accountBytes, nonceBytes, difficultyBytes, workBytes);
  
  // Calculate the hash
  const hash = blake2AsU8a(input, 256);
  // Convert hash to BN for comparison
  const hashValue = hashToU256(hash);
  
  // Calculate target: 2^(256-difficulty)
  const target = new BN(2).pow(new BN(256 - difficulty));
  
  // The proof is valid if hash < target
  return hashValue.lt(target);
}

// Parse command line arguments
async function parseArgs() {
  const args = process.argv.slice(2);
  
  // Default values
  let accountId = DEFAULT_ACCOUNT;
  let nonce = DEFAULT_NONCE;
  let difficulty = DEFAULT_DIFFICULTY;
  let maxAttempts = DEFAULT_MAX_ATTEMPTS;
  let verify = false;
  let workToVerify = '';
  
  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--account':
      case '-a':
        accountId = args[++i];
        break;
      case '--nonce':
      case '-n':
        nonce = parseInt(args[++i], 10);
        break;
      case '--difficulty':
      case '-d':
        difficulty = parseInt(args[++i], 10);
        break;
      case '--max-attempts':
      case '-m':
        maxAttempts = parseInt(args[++i], 10);
        break;
      case '--verify':
      case '-v':
        verify = true;
        workToVerify = args[++i];
        break;
      case '--help':
      case '-h':
        printHelp();
        process.exit(0);
        break;
    }
  }
  
  // Wait for crypto libraries to be ready
  await cryptoWaitReady();
  
  if (verify) {
    // Verify an existing proof
    const isValid = verifyProofOfWork(accountId, nonce, difficulty, workToVerify);
    console.log(`\nVerification result: ${isValid ? 'VALID ✅' : 'INVALID ❌'}`);
    if (isValid) {
      console.log(`The provided proof-of-work is valid for the given parameters`);
    } else {
      console.log(`The provided proof-of-work is NOT valid for the given parameters`);
    }
  } else {
    // Generate a new proof
    console.log(`Generating proof-of-work with difficulty ${difficulty}...`);
    const startTime = Date.now();
    
    const proof = await findValidProofOfWork(accountId, nonce, difficulty, maxAttempts);
    
    const endTime = Date.now();
    const duration = (endTime - startTime) / 1000;
    
    if (proof) {
      console.log(`\n✅ Generated valid proof-of-work in ${duration.toFixed(2)} seconds`);
      console.log(`Proof: ${proof}`);
      
      // Double-check by verifying
      const verified = verifyProofOfWork(accountId, nonce, difficulty, proof);
      console.log(`Self-verification: ${verified ? 'VALID ✅' : 'INVALID ❌'}`);
    } else {
      console.log(`\n❌ Failed to generate a valid proof-of-work in ${duration.toFixed(2)} seconds`);
    }
  }
}

// Print help
function printHelp() {
  console.log(`
PoW Generator for CTF Pallet
----------------------------

Generate or verify a proof-of-work for the CTF pallet.

Usage:
  bun run generate-pow.ts [options]

Options:
  --account, -a       Account ID (default: ${DEFAULT_ACCOUNT})
  --nonce, -n         Account nonce (default: ${DEFAULT_NONCE})
  --difficulty, -d    Difficulty level (default: ${DEFAULT_DIFFICULTY})
  --max-attempts, -m  Maximum attempts (default: ${DEFAULT_MAX_ATTEMPTS})
  --verify, -v        Verify a proof instead of generating (provide the proof)
  --help, -h          Show this help message

Examples:
  # Generate a proof with default parameters
  bun run generate-pow.ts

  # Generate a proof with custom parameters
  bun run generate-pow.ts --account 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty --nonce 5 --difficulty 12

  # Verify an existing proof
  bun run generate-pow.ts --verify 0x1234...abcd --account 5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty --nonce 5 --difficulty 12
`);
}

// Run the script
parseArgs().catch(console.error);