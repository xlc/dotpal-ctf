#!/usr/bin/env bun
// CTF Pallet Interaction Script - generated by polka.codes
// This script demonstrates interaction with the CTF (Capture-the-Flag) pallet
// using Polkadot.js and Bun runtime

import { ApiPromise, WsProvider, Keyring } from '@polkadot/api';
import { cryptoWaitReady } from '@polkadot/util-crypto';
import { u8aToHex, hexToU8a, stringToU8a, u8aConcat } from '@polkadot/util';
import { blake2AsU8a, blake2AsHex } from '@polkadot/util-crypto';
import { BN } from 'bn.js';

// Connection parameters
const NODE_URL = 'ws://127.0.0.1:9944'; // Default local node WebSocket endpoint

// Main function
async function main() {
  console.log('Connecting to Substrate node...');
  
  // Wait for the crypto libraries to be ready
  await cryptoWaitReady();
  
  // Connect to the node
  const wsProvider = new WsProvider(NODE_URL);
  const api = await ApiPromise.create({ 
    provider: wsProvider,
    types: {
      // Optional custom types if needed
    }
  });
  
  // Check if connection is established
  const nodeInfo = await api.rpc.system.chain();
  console.log(`Connected to ${nodeInfo.toString()}`);
  
  // Setup keyring and account (using Alice for testing)
  const keyring = new Keyring({ type: 'sr25519' });
  const alice = keyring.addFromUri('//Alice');
  console.log(`Using account: ${alice.address}`);
  
  // Check initial score
  await checkScore(api, alice.address);
  
  // Set PoW difficulty
  const difficulty = 10; // Adjust as needed
  console.log(`Using difficulty: ${difficulty}`);
  
  // Generate and submit proof of work
  console.log('Generating proof of work...');
  const proofResult = await generateAndSubmitProof(api, alice, difficulty);
  if (proofResult) {
    console.log('Successfully submitted proof of work!');
    
    // Check updated score
    await checkScore(api, alice.address);
    
    // Withdraw points
    await withdrawPoints(api, alice);
    
    // Check final state after withdrawal
    await checkScore(api, alice.address);
  }
  
  // Disconnect from the node
  await api.disconnect();
  console.log('Disconnected from node');
}

// Check the score for an account
async function checkScore(api: ApiPromise, address: string) {
  try {
    // Query the score state from storage
    // Note: in Polkadot.js the pallet name is camelCased from the runtime registration (CTFPallet -> ctfPallet)
    const scoreState = await api.query.ctfPallet.score(address);
    
    if (scoreState) {
      if (scoreState.isEnabled) {
        const points = scoreState.asEnabled.toNumber();
        console.log(`Current score: ${points} points`);
        return points;
      } else if (scoreState.isDisabled) {
        console.log('Score is disabled (withdrawn)');
        return -1; // Indicating disabled
      }
    }
    console.log('No score found (default to 0)');
    return 0;
  } catch (error) {
    console.error('Error checking score:', error);
    return 0;
  }
}

// Generate a valid proof of work and submit it
async function generateAndSubmitProof(api: ApiPromise, account: any, difficulty: number): Promise<boolean> {
  try {
    // Get current nonce
    const accountInfo = await api.query.system.account(account.address);
    const nonce = accountInfo.nonce.toNumber();
    console.log(`Current account nonce: ${nonce}`);
    
    // Generate a valid proof of work
    const proofOfWork = await findValidProofOfWork(account.address, nonce, difficulty);
    if (!proofOfWork) {
      console.error('Failed to generate a valid proof of work');
      return false;
    }
    
    console.log(`Found valid proof of work: ${proofOfWork}`);
    
    // Submit the solution
    console.log('Submitting solution to the chain...');
    const txHash = await api.tx.ctfPallet
      .submitSolution(difficulty, proofOfWork)
      .signAndSend(account);
    
    console.log(`Transaction submitted with hash: ${txHash.toHex()}`);
    
    // Wait for the transaction to be finalized
    return new Promise((resolve) => {
      setTimeout(() => resolve(true), 6000); // Wait for approximately 1 block
    });
  } catch (error) {
    console.error('Error submitting proof of work:', error);
    return false;
  }
}

// Withdraw points from the CTF pallet
async function withdrawPoints(api: ApiPromise, account: any): Promise<boolean> {
  try {
    console.log('Withdrawing points...');
    const txHash = await api.tx.ctfPallet
      .withdraw()
      .signAndSend(account);
    
    console.log(`Withdrawal transaction submitted with hash: ${txHash.toHex()}`);
    
    // Wait for the transaction to be finalized
    return new Promise((resolve) => {
      setTimeout(() => resolve(true), 6000); // Wait for approximately 1 block
    });
  } catch (error) {
    console.error('Error withdrawing points:', error);
    return false;
  }
}

// Find a valid proof of work by trying different values
async function findValidProofOfWork(
  accountId: string, 
  nonce: number, 
  difficulty: number, 
  maxAttempts = 100000
): Promise<string | null> {
  // Convert account ID to bytes
  const accountBytes = stringToU8a(accountId);
  const nonceBytes = new Uint8Array(new BN(nonce).toArray('le', 4));
  const difficultyBytes = new Uint8Array(new BN(difficulty).toArray('le', 4));
  
  // Calculate target value: 2^(256-difficulty)
  const target = new BN(2).pow(new BN(256 - difficulty));
  
  console.log(`Searching for valid proof (target: ${target.toString(16)})`);
  console.log(`This may take some time depending on difficulty...`);
  
  // Try different values until we find a valid proof or reach max attempts
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    // Generate a random work value
    const workBytes = crypto.getRandomValues(new Uint8Array(32));
    
    // Concatenate all inputs
    const input = u8aConcat(accountBytes, nonceBytes, difficultyBytes, workBytes);
    
    // Calculate the hash using blake2
    const hash = blake2AsU8a(input, 256);
    
    // Convert hash to BN for comparison
    const hashValue = hashToU256(hash);
    
    // Check if the hash is less than the target
    if (hashValue.lt(target)) {
      // We found a valid proof!
      return u8aToHex(workBytes);
    }
    
    // Show progress every 10000 attempts
    if (attempt % 10000 === 0 && attempt > 0) {
      console.log(`Tried ${attempt} attempts...`);
    }
  }
  
  console.log(`Reached maximum attempts (${maxAttempts}) without finding a valid proof`);
  return null;
}

// Convert a hash byte array to U256 for comparison
function hashToU256(hash: Uint8Array): BN {
  // The hash is a little-endian byte array, but BN expects big-endian
  // So we need to reverse the bytes for correct comparison
  const reversedHash = hash.slice().reverse();
  return new BN(reversedHash);
}

// Run the main function
main().catch(console.error);